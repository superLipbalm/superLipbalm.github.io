{"componentChunkName":"component---src-templates-post-template-tsx","path":"/for...of/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>저기요! 인상이 참 선하신데…</p>\n<p>혹시 이터레이터를 아십니까?</p>\n<p>ES6이전의 자바스크립트에서 배열은 다음과 같은 방법으로 순회하였습니다.</p>\n<p>var arr = [1, 2, 3];</p>\n<p>for (var i = 0; i &#x3C; arr.length; i++) {\nconsole.log(arr[i]);\n}</p>\n<p>배열의 length 프로퍼티와 인덱스를 사용해서요.</p>\n<p>그리고 ES6부터는 for … of 명령문을 이용해 더 간결한 선언적 표현으로 배열을 순회 할 수 있게되었습니다.</p>\n<p>const arr = [1, 2, 3];\nfor (const el of arr) {\nconsole.log(el);\n}</p>\n<p>그런데 여기서 궁금증이 생깁니다. for … of는 어떻게 동작하는 것일까요?</p>\n<p>우리가 이전에 썻던 방법처럼 인덱스를 이용해 순회하는 것일까요?</p>\n<p>우리는 for … of를 이용해 배열처럼 숫자 인덱스로 요소에 접근할 수 없는 Map, Set 객체 등도 순회 할 수 있습니다.</p>\n<p>const map = new Map([[‘a’, 1], [‘b’, 1], [‘c’, 1]]);</p>\n<p>for (const el of map) {\nconsole.log(el);\n}</p>\n<p>const set = new Set([1, 2, 2, 3, 4]);</p>\n<p>for (const el of set) {\nconsole.log(el);\n}</p>\n<p>따라서 숫자 인덱스를 사용하는 방법은 아닙니다. 그렇다면 어떻게 순회하는 것일까요?</p>\n<p>그 비밀은 iteration 프로토콜에 있습니다.</p>\n<p>비밀에 대해 알아보기 위해 우선 iteration 프로토콜에 대해 알아봅시다.</p>\n<p>iteration 프로토콜은 iterable 프로토콜과 iterator 프로토콜로 이루어져 있습니다.</p>\n<p>iterable 프로토콜을 따르는 객체, 즉 iterable 객체는 @@iterator 메소드를 갖고 있습니다.</p>\n<p>객체에 [Symbol.iterator] key에 iterator 객체를 반환하는 함수를 갖고 있는 것이죠.</p>\n<p>그렇다면 iterator 객체는 무엇일까요?</p>\n<p>iterator 객체는 iterator 프로토콜을 따르는 객체로 done과 value 두가지 속성을 갖는 객체를 반환하는 next()메소드를 갖고 있습니다.</p>\n<p>done은 iterator의 작업이 모두 끝났는지를 나타내는 속성으로 작업이 남아 있다면 false, 모두 완료되었다면 true가 됩니다.</p>\n<p>value는 iterator로 부터 반환되는 모든 자바스크립트 값입니다.</p>\n<p>const arr = [1, 2, 3];\nconst iter = arr<a href=\"\">Symbol.iterator</a>;</p>\n<p>console.log(iter.next()); // { value: 1, done: false }\nconsole.log(iter.next()); // { value: 2, done: false }\nconsole.log(iter.next()); // { value: 3, done: false }\nconsole.log(iter.next()); // { value: undefined, done: true }</p>\n<p>이제 iterable과 iterator에 대해 알아보았으니, 다시 for … of의 비밀에 대해 알아보도록 합시다.</p>\n<p>for … of를 통해 순회할 수 있는 객체의 공통점은 모두 iterable한 객체라는 겁니다.</p>\n<p>Map, Set, Array 등은 모두 iterralbe 객체로 [Symbol.iterator] 속성에 iterator를 반환하는 함수를 갖고 있죠.</p>\n<p>for …of 반복문에서는 이러한 iterable 객체의 iterator를 이용해 순회를 합니다.</p>\n<p>iterator의 next()를 계속 호출해 value를 변수에 할당하며 반복문을 실행하고, { done: true }가 반환되면 탈출하는 방법으로요!</p>\n<p>신기하고 재미있는 iteration 프로토콜에 대한 자세한 내용들을 아래 링크에서 확인해보세요!</p>\n<p>Iteration protocols - JavaScript | MDN (mozilla.org)\nfor…of - JavaScript | MDN (mozilla.org)\nArray.prototype<a href=\"\">@@iterator</a> - JavaScript | MDN (mozilla.org)\n반복기 및 생성기 - JavaScript | MDN (mozilla.org)\nfunction* - JavaScript | MDN (mozilla.org)</p>\n<p>피드백은 언제나 환영합니다! 부족한 글 읽어주셔서 감사합니다!:man-bowing:</p>","frontmatter":{"title":"이터러블과 이터레이터. for...of는 어떻게 동작할까?","summary":"for...of는 어떻게 동작할까?","date":"2021.08.19","categories":["JavaScript"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAU6McNBMP//EABsQAAICAwEAAAAAAAAAAAAAAAECAxEABCIx/9oACAEBAAEFAoGoyyFUOyxIPD+Xn//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABsQAAIBBQAAAAAAAAAAAAAAAAACARAREiGR/9oACAEBAAY/AjJJNqvC1f/EABkQAQEBAAMAAAAAAAAAAAAAAAERACExQf/aAAgBAQABPyEjuVdSa0oxZrjJBF1Pu//aAAwDAQACAAMAAAAQMO//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxBH/8QAGhABAAMBAQEAAAAAAAAAAAAAAQARITFBUf/aAAgBAQABPxBpeDsKs5OCa1sXMrrQjfamBKnFn2Pcp//Z","aspectRatio":1.7699115044247788,"src":"/static/875a7bd5fef2153cc26adcf37ed177c8/addc4/intro.jpg","srcSet":"/static/875a7bd5fef2153cc26adcf37ed177c8/ae57a/intro.jpg 200w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/86652/intro.jpg 400w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/addc4/intro.jpg 800w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/7d728/intro.jpg 1200w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/cbda8/intro.jpg 1600w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/b28e2/intro.jpg 5507w","srcWebp":"/static/875a7bd5fef2153cc26adcf37ed177c8/210fa/intro.webp","srcSetWebp":"/static/875a7bd5fef2153cc26adcf37ed177c8/8444f/intro.webp 200w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/42fc5/intro.webp 400w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/210fa/intro.webp 800w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/3058d/intro.webp 1200w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/747be/intro.webp 1600w,\n/static/875a7bd5fef2153cc26adcf37ed177c8/e5b63/intro.webp 5507w","sizes":"(max-width: 800px) 100vw, 800px"},"original":{"src":"/static/intro-875a7bd5fef2153cc26adcf37ed177c8.jpg"}}}}}}]}},"pageContext":{"slug":"/for...of/","prev":{"slug":"/프로그래머스[Level 2] 쿼드압축 후 개수 세기/","title":"쿼드압축 후 개수 세기"}}},"staticQueryHashes":["1089444523"]}